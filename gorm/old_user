package user

import (
	"crypto/rand"
	"math/big"
	"errors"
	"log"
	"regexp"
	"time"
	"net/http"
	"strconv"
	"encoding/json"

	"github.com/asaskevich/govalidator"
	"github.com/gin-gonic/gin"
	"github.com/jinzhu/gorm"
	"github.com/theduke/gormigrate"
	"golang.org/x/crypto/bcrypt"

	dukegin "github.com/theduke/appkit/gin"
	"github.com/theduke/appkit/users"
)



type User struct {
	ID uint `gorm:"primary_key"`

	Username string `sql:"size:100"`
	Email    string `sql:"size:255; not null; unique"`

	PasswordHash string `sql:"size:100;not null"  jsonapi:"name=password-hash"`

	LastLogin time.Time

	CreatedAt time.Time `jsonapi:"name=created-at"`
	UpdatedAt time.Time `jsonapi:"name=updated-at"`

	Profile interface{} `gorm:"-" sql:"-"`
}

/**
 * Implements api2go interface.
 * See https://github.com/manyminds/api2go
 */
func (t User) GetName() string {
	return "users"
}

/**
 * Implements api2go interface.
 * See https://github.com/manyminds/api2go
 */
func (u User) GetID() string {
	return strconv.FormatUint(uint64(u.ID), 10)
}

/**
 * Implements api2go interface.
 * See https://github.com/manyminds/api2go
 */
func (u *User) SetID(rawId string) error {
	id, err := strconv.Atoi(rawId)
	if err != nil {
		return errors.New("invalid_id")
	}	

	u.ID = uint(id)
	return nil
}

// Implement User interface.
func (u *User) SetIsActive(isActive bool) {
	u.Active = isActive
}

func (u *User) IsActive() bool {
	return u.active
}

func (u *User) SetUsername(string)
func (u *User) GetUsername() string

func (u *User) SetEmail(string)
func (u *User) GetEmail() string

func (u *User) SetLastLogin(time.Time)
func (u *User) GetLastLogin() time.Time

func (u *User) SetCreatedAt(time.Time)
func (u *User) GetCreatedAt() time.Time

func (u *User) SetUpdatedAt(time.Time)
func (u *User) GetUpdatedAt() time.Time

	SetProfile(interface{})
	GetProfile() interface{}


type Session struct {
	Token string `gorm:"primary_key" sql:"size:100"`

	UserID uint `sql:"not null"`

	StartedAt  time.Time `sql:"not null"`
	ValidUntil time.Time `sql:"not null"`
}

func (s Session) IsGuest() bool {
	return s.UserID == 0;
}

func (s Session) GetUser(db *gorm.DB) *User {
	user := User{}
	if err := db.Where("id = ?", s.UserID).First(&user).Error; err != nil {
		return nil
	}

	return &user
}

func CreateUser(db *gorm.DB, name, email, password string) (*User, error) {
	// Check username.

	if name != "" {
		if match, _ := regexp.MatchString("[a-z][a-z0-9_]+", name); !match {
			log.Printf("username %v is invalid \n", name)
			return nil, errors.New("invalid_username")
		}
	}

	if !govalidator.IsEmail(email) {
		return nil, errors.New("invalid_email")
	}

	// Check if username and email are unique
	user := User{}

	db.Where("username = ? OR email = ?", name, email).First(&user)
	if user.ID != 0 {
		if user.Username == name {
			return nil, errors.New("username_exists")
		} else if user.Email == email {
			return nil, errors.New("email_exists")
		}
	}

	user.Username = name
	user.Email = email

	// Hashing the password with the cost of 10
	hash, err := bcrypt.GenerateFromPassword([]byte(password), 10)
	if err != nil {
		return nil, err
	}

	user.PasswordHash = string(hash)

	if db.Create(&user); db.Error != nil {
		return nil, errors.New("could_not_create")
	}

	return &user, nil
}

func UserSetPassword(db *gorm.DB, user *User, password string) error {
	// Hashing the password with the cost of 10
	hash, err := bcrypt.GenerateFromPassword([]byte(password), 10)
	if err != nil {
		return err
	}

	if err := db.Model(user).Update("password_hash", hash).Error; err != nil {
		return err
	}

	return nil
}

func DeleteUser(db *gorm.DB, id uint) error {
	if err:= db.Where("id = ?", id).Delete(User{}).Error; err != nil {
  	return errors.New("db_error")
  }

  return nil
}

/**
 * Validate password for a user account.
 * Might provide either username or email as "name"
 *
 * Returns user id if successful.
 */
func CheckUser(db *gorm.DB, name, password string) (uint, error) {
	user := User{}
	db.Where("username = ? OR email = ?", name, name).First(&user)

	if user.ID == 0 {
		return 0, errors.New("unknown_user")
	}

	if err := bcrypt.CompareHashAndPassword([]byte(user.PasswordHash), []byte(password)); err != nil {
		return 0, err
	}

	return user.ID, nil
}



func StartSession(db *gorm.DB, name, password string) (*Session, error) {
	userId, err := CheckUser(db, name, password)

	if err != nil {
		return nil, err
	}

	token := randomToken(32)
	if token == "" {
		return nil, errors.New("token_creation_failed")
	}

	now := time.Now()
	session := Session{
		Token:      token,
		UserID:     userId,
		StartedAt:  now,
		ValidUntil: now.Add(time.Hour * 12),
	}
	if err := db.Create(&session).Error; err != nil {
		return nil, errors.New("session_insert_failed")
	}

	return &session, nil
}

func CheckSession(db *gorm.DB, token string) (*Session, error) {
	var session Session

	if err := db.Where("token = ?", token).First(&session).Error; err != nil {
		return nil, errors.New("db_error")
	}
	if session.Token == "" {
		return nil, errors.New("token_invalid")
	}

	if session.ValidUntil.Sub(time.Now()) < 0 {
		return nil, errors.New("token_expired")
	}

	// Prolong session
	session.ValidUntil = time.Now().Add(time.Hour * 12)
	if err := db.Save(&session).Error; err != nil {
		return nil, errors.New("db_error")
	}

	return &session, nil
}

func EndSession(db *gorm.DB, token string) (*Session, error) {
	session, err := CheckSession(db, token)
	if err != nil {
		return nil, err
	}

	// Invalidate session by setting validuntil to now.
	session.ValidUntil = time.Now()
	err = db.Save(session).Error
	if err != nil {
		return nil, errors.New("db_error")
	}

	return session, nil
}

/**
 * Gin routes.
 */

 func HttpJsonResponse(w http.ResponseWriter, httpStatus int, err string, data map[string]interface{}) {

 	if err != "" {
 		data = map[string]interface{}{
 			"success": false,
 			"error": map[string]interface{} {
 				"code": err,
 				"title": err,
 				"status": strconv.Itoa(httpStatus),
 			},
 		}
 	}

 	json, _ := json.Marshal(data)

 	w.WriteHeader(httpStatus)
 	w.Write(json)
 }

func HttpLogin(db *gorm.DB, w http.ResponseWriter, r *http.Request) {
	r.ParseForm()
	name := r.PostFormValue("user")
	if name == "" {
		HttpJsonResponse(w, 400, "user_required", nil)
		return
	}

	pw := r.PostFormValue("password")
	if pw == "" {
		HttpJsonResponse(w, 400, "password_required", nil)
	}

	session, err := StartSession(db, name, pw)
	if err != nil {
		HttpJsonResponse(w, 403, err.Error(), nil)
		return
	}

	HttpJsonResponse(w, 200, "", map[string]interface{}{
		"success": true,
		"userId":  session.UserID,
		"token":   session.Token,
		"expires": int64(session.ValidUntil.Sub(time.Now()).Seconds()),
	})
}

func HttpCheck(db *gorm.DB, w http.ResponseWriter, r *http.Request) {
	token := r.Header.Get("Authentication")
	if token == "" {
		HttpJsonResponse(w, 400, "token_required", nil)
		return
	}

	session, err := CheckSession(db, token)
	if err != nil {
		HttpJsonResponse(w, 403, "session_invalid", map[string]interface{}{
			"success": false,
			"error": err.Error(),
		})
		return
	}
	

	HttpJsonResponse(w, 200, "", map[string]interface{}{
		"success": true,
		"userId":  session.UserID,
		"token":   session.Token,
		"expires": int64(session.ValidUntil.Sub(time.Now()).Seconds()),
	})
}

func HttpLogout(db *gorm.DB, w http.ResponseWriter, r *http.Request) {
	token := r.Header.Get("Authentication")
	if token == "" {
		HttpJsonResponse(w, 400, "token_required", nil)
		return
	}

	_, err := EndSession(db, token)
	if err != nil {
		HttpJsonResponse(w, 500, err.Error(), nil)
		return
	}

	HttpJsonResponse(w, 200, "", map[string]interface{}{"success": true})
}

func GinLogin(c *gin.Context) {
	rawDb, ok := c.Get("db")
	db := rawDb.(*gorm.DB)
	if !ok || db == nil {
		dukegin.ErrorResponse(500, "db_not_found", nil, c)
		return
	}

	name := c.PostForm("user")
	if name == "" {
		dukegin.ErrorResponse(400, "user_required", nil, c)
		return
	}

	pw := c.PostForm("password")
	if pw == "" {
		dukegin.ErrorResponse(400, "password_required", nil, c)
		return
	}

	session, err := StartSession(db, name, pw)
	if err != nil {
		dukegin.ErrorResponse(403, err.Error(), nil, c)
		return
	}

	c.JSON(200, gin.H{
		"success": true,
		"userId":  session.UserID,
		"token":   session.Token,
		"expires": int64(session.ValidUntil.Sub(time.Now()).Seconds()),
	})
}

func GinLogout(c *gin.Context) {
	rawDb, ok := c.Get("db")
	db := rawDb.(*gorm.DB)
	if !ok || db == nil {
		dukegin.ErrorResponse(500, "db_not_found", nil, c)
		return
	}

	token := c.PostForm("auth_token")
	if token == "" {
		dukegin.ErrorResponse(400, "token_required", nil, c)
		return
	}

	_, err := EndSession(db, token)
	if err != nil {
		dukegin.ErrorResponse(500, err.Error(), nil, c)
		return
	}

	c.JSON(200, gin.H{
		"success": true,
	})
}

func GinDoSignup(c *gin.Context) (*User, error) {
	rawDb, ok := c.Get("db")
	db := rawDb.(*gorm.DB)
	if !ok || db == nil {
		panic("gorm db not in gin context")
	}

	name := c.PostForm("username")
	email := c.PostForm("email")
	pw := c.PostForm("password")

	if name == "" || email == "" || pw == "" {
		return nil, errors.New("username_email_password_missing")
	}

	user, err := CreateUser(db, name, email, pw)
	if err != nil {
		return nil, err
	}

	return user, err
}

func GinSignUp(c *gin.Context) {
	user, err := GinDoSignup(c)
	if err != nil {
		dukegin.ErrorResponse(500, err.Error(), nil, c)
		return
	}

	c.JSON(200, gin.H{
		"success": true,
		"userId":  user.ID,
	})
}

func TokenAuthMiddleware(db *gorm.DB) gin.HandlerFunc {
	return func(c *gin.Context) {

		// Retrieve the auth token either from the
		// auth_token header or the auth_token post param
		// or the auth_token GET query param.
		token := c.Request.Header.Get("Authorization")
		if token == "" {
			token = c.Request.FormValue("auth_token")
			if token == "" {
				token = c.Query("auth_token")
			}
		}

		if token == "" {
			dukegin.ErrorResponse(401, "token_required", nil, c)
			return
		}

		session, err := CheckSession(db, token)
		if err != nil {
			dukegin.ErrorResponse(500, err.Error(), nil, c)
			return
		}

		c.Set("session", session)
		c.Set("userId", session.UserID)

		c.Next()
	}
}
